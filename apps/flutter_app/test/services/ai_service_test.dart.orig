import 'package:flutter_test/flutter_test.dart';
import 'package:http/http.dart' as http;
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';
import 'package:valora_app/services/ai_service.dart';
import 'package:valora_app/services/auth_service.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';

@GenerateNiceMocks([MockSpec<http.Client>()])
import 'ai_service_test.mocks.dart';

class MockAuthService extends Mock implements AuthService {
  @override
  Future<String?> getToken() async => 'fake-token';
}

void main() {
  late AiService aiService;
  late MockClient mockClient;
  late MockAuthService mockAuthService;

  setUp(() async {
    await dotenv.load(fileName: '.env.example');
    mockClient = MockClient();
    mockAuthService = MockAuthService();
    aiService = AiService(client: mockClient, authService: mockAuthService);
  });

  test('baseUrl falls back if not in env', () {
    when(mockClient.get(any, headers: anyNamed('headers')))
        .thenAnswer((_) async => http.Response('[]', 200));
    expect(aiService.getHistory(), completes);
  });

  test('baseUrl falls back to AppConfig if no dot env', () {
    // If we instantiate with no arguments, it should initialize fine
    final service = AiService(authService: mockAuthService);
    when(mockAuthService.getToken()).thenAnswer((_) async => null);
    // the implicit check is simply making sure it doesn't crash on instantiation
    expect(service, isNotNull);
  });

  test('sendMessage sanitizes backend error details', () async {
    when(mockClient.post(
      any,
      headers: anyNamed('headers'),
      body: anyNamed('body'),
    )).thenAnswer((_) async => http.Response('{"detail": "Secret DB error", "trace_id": "12345"}', 500));

    expect(
      () => aiService.sendMessage(prompt: 'test'),
      throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Failed to send message. (Trace ID: 12345)'))),
    );
  });

  test('sendMessage handles missing trace_id gracefully', () async {
    when(mockClient.post(
      any,
      headers: anyNamed('headers'),
      body: anyNamed('body'),
    )).thenAnswer((_) async => http.Response('{"detail": "Secret DB error"}', 500));

    expect(
      () => aiService.sendMessage(prompt: 'test'),
      throwsA(isA<Exception>().having((e) => e.toString(), 'message', isNot(contains('Trace ID:')))),
    );
  });

  test('sendMessage handles success', () async {
    when(mockClient.post(
      any,
      headers: anyNamed('headers'),
      body: anyNamed('body'),
    )).thenAnswer((_) async => http.Response('{"response": "ok", "conversationId": "c1"}', 200));

    final response = await aiService.sendMessage(prompt: 'test');
    expect(response['response'], 'ok');
    expect(response['conversationId'], 'c1');
  });

  test('getHistory throws on error', () async {
    when(mockClient.get(any, headers: anyNamed('headers')))
        .thenAnswer((_) async => http.Response('Error', 500));

    expect(() => aiService.getHistory(), throwsException);
  });

  test('getMessages handles success', () async {
    when(mockClient.get(any, headers: anyNamed('headers')))
        .thenAnswer((_) async => http.Response('{"messages": [{"role": "user", "content": "hi"}]}', 200));

    final msgs = await aiService.getMessages('1');
    expect(msgs.length, 1);
    expect(msgs[0].role, 'user');
    expect(msgs[0].content, 'hi');
  });

  test('getMessages throws 404', () async {
    when(mockClient.get(any, headers: anyNamed('headers')))
        .thenAnswer((_) async => http.Response('Not found', 404));

    expect(
      () => aiService.getMessages('1'),
      throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Conversation not found'))),
    );
  });

  test('getMessages throws 500', () async {
    when(mockClient.get(any, headers: anyNamed('headers')))
        .thenAnswer((_) async => http.Response('Error', 500));

    expect(
      () => aiService.getMessages('1'),
      throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Failed to load messages'))),
    );
  });

  test('deleteConversation handles success', () async {
    when(mockClient.delete(any, headers: anyNamed('headers')))
        .thenAnswer((_) async => http.Response('', 204));

    await aiService.deleteConversation('1');
    verify(mockClient.delete(any, headers: anyNamed('headers'))).called(1);
  });

  test('deleteConversation throws error', () async {
    when(mockClient.delete(any, headers: anyNamed('headers')))
        .thenAnswer((_) async => http.Response('', 500));

    expect(
      () => aiService.deleteConversation('1'),
      throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Failed to delete conversation'))),
    );
  });
}
