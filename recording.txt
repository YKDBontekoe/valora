1.  **Testing for Coverage**: Adding  to  required dedicated unit tests () to ensure high code coverage, as simple integration or widget tests might not exercise all error paths (like server errors or network exceptions triggering fallbacks).
2.  **Flutter Lints in CI**: The CI pipeline enforces strict linting where warnings (like ) cause build failures. It's crucial to clean up imports after refactoring or moving code.
3.  **Backend Integration Testing**:  with  provides a reliable way to test new API endpoints () without mocking the entire ASP.NET Core stack.
4.  **Covering Default Values**: To achieve high code coverage on models with default values (e.g.,  with ), tests must explicitly simulate partial or empty responses to trigger those fallback paths.
5.  **Service Initialization Tests**: Services that load data asynchronously on  (like ) should have tests verifying their state *before* initialization to ensure default getters (using ) are covered.
6.  **Concurrency Testing**: Testing loading flags (re-entrancy guards) requires mocking Futures with  to control execution timing manually.
7.  **Conditional UI Rendering**: To cover conditional UI blocks (e.g., ), widget tests must simulate state where the condition is true, not just rely on defaults where it might be false.
8.  **Retry Logic in Tests**: When testing services that use  (like ), it is critical to inject  in unit tests to prevent timeouts and ensure failures propagate immediately for assertion.
